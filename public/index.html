<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>æ™ºèƒ½å¥åº·é—®è¯Š</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Vue 3 -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <!-- Marked for Markdown parsing if needed -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- ECharts for Sankey Diagram -->
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
    <style>
        /* iOSå®‰å…¨åŒºåŸŸé€‚é… */
        :root {
            --sat: env(safe-area-inset-top);
            --sab: env(safe-area-inset-bottom);
            --sal: env(safe-area-inset-left);
            --sar: env(safe-area-inset-right);
        }
        .chat-container {
            flex: 1;
            overflow-y: auto;
            background: linear-gradient(180deg, #f8fafc 0%, #f1f5f9 100%);
            min-height: 0; /* ç¡®ä¿flexå­å…ƒç´ å¯ä»¥æ”¶ç¼© */
        }
        /* ç§»åŠ¨ç«¯åº•éƒ¨å®‰å…¨åŒºåŸŸ */
        .safe-bottom {
            padding-bottom: calc(1rem + var(--sab, 0px));
        }
        .fade-enter-active, .fade-leave-active {
            transition: opacity 0.5s;
        }
        .fade-enter-from, .fade-leave-to {
            opacity: 0;
        }
        /* æ¶ˆæ¯æ°”æ³¡åŠ¨ç”» */
        .message-bubble {
            animation: slideIn 0.3s ease-out;
        }
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        /* è‡ªå®šä¹‰æ»šåŠ¨æ¡ */
        .chat-container::-webkit-scrollbar {
            width: 6px;
        }
        .chat-container::-webkit-scrollbar-track {
            background: transparent;
        }
        .chat-container::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }
        .chat-container::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
        /* è¾“å…¥æ¡†èšç„¦æ•ˆæœ */
        .input-glow:focus {
            box-shadow: 0 0 0 3px rgba(94, 37, 144, 0.15);
        }
        /* æŒ‰é’®æ‚¬åœæ•ˆæœ */
        .btn-hover:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(94, 37, 144, 0.25);
        }
        /* å¤´åƒå…‰æ™•æ•ˆæœ */
        .avatar-glow {
            box-shadow: 0 2px 8px rgba(94, 37, 144, 0.2);
        }
        /* è¯­éŸ³å½•éŸ³å…‰æ™•åŠ¨ç”» */
        .voice-glow {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(147, 51, 234, 0.4) 0%, rgba(168, 85, 247, 0.2) 40%, transparent 70%);
            animation: pulse-glow 1.5s ease-in-out infinite;
            pointer-events: none;
            z-index: 50;
        }
        @keyframes pulse-glow {
            0%, 100% {
                transform: translateX(-50%) scale(1);
                opacity: 0.6;
            }
            50% {
                transform: translateX(-50%) scale(1.2);
                opacity: 0.8;
            }
        }
        /* æ³¢æµªéŸ³é¢‘åŠ¨ç”» */
        .audio-wave {
            position: fixed;
            bottom: 110px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            z-index: 51;
            pointer-events: none;
        }
        .audio-wave-bar {
            width: 4px;
            background: linear-gradient(to top, #9333ea, #a855f7);
            border-radius: 2px;
            animation: wave 1s ease-in-out infinite;
        }
        .audio-wave-bar:nth-child(1) { height: 20px; animation-delay: 0s; }
        .audio-wave-bar:nth-child(2) { height: 30px; animation-delay: 0.1s; }
        .audio-wave-bar:nth-child(3) { height: 40px; animation-delay: 0.2s; }
        .audio-wave-bar:nth-child(4) { height: 30px; animation-delay: 0.3s; }
        .audio-wave-bar:nth-child(5) { height: 20px; animation-delay: 0.4s; }
        @keyframes wave {
            0%, 100% {
                transform: scaleY(0.5);
                opacity: 0.5;
            }
            50% {
                transform: scaleY(1);
                opacity: 1;
            }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-slate-50 to-gray-50 text-gray-800 font-sans">
    <div id="app" class="w-full md:max-w-2xl mx-auto h-[100dvh] flex flex-col md:shadow-2xl bg-white relative">
        
        <!-- Header -->
        <header class="flex-shrink-0 bg-gradient-to-r from-purple-700 via-purple-600 to-purple-800 text-white p-3 md:p-4 shadow-lg relative">
            <!-- è£…é¥°æ€§èƒŒæ™¯å›¾æ¡ˆ -->
            <div class="absolute inset-0 opacity-10 overflow-hidden">
                <div class="absolute top-0 right-0 w-24 md:w-32 h-24 md:h-32 bg-white rounded-full -translate-y-1/2 translate-x-1/2"></div>
                <div class="absolute bottom-0 left-0 w-20 md:w-24 h-20 md:h-24 bg-white rounded-full translate-y-1/2 -translate-x-1/2"></div>
            </div>
            <div class="flex items-center justify-between relative z-10">
                <div class="flex items-center space-x-2 md:space-x-3">
                    <!-- Logoå›¾æ ‡ -->
                    <div class="w-9 h-9 md:w-10 md:h-10 bg-white bg-opacity-20 rounded-xl flex items-center justify-center backdrop-blur-sm">
                        <span class="text-xl md:text-2xl">ğŸ¥</span>
                    </div>
                    <div>
                        <h1 class="text-base md:text-lg font-bold">THUæ™ºèƒ½åˆ†è¯Šè¾…åŠ©ç³»ç»Ÿ</h1>
                        <p class="text-xs opacity-80">ä¸“ä¸š Â· è´´å¿ƒ Â· ä¾¿æ·</p>
                    </div>
                </div>
                <div class="flex items-center space-x-2">
                    <!-- è‡ªå®šä¹‰æ¨¡å‹é€‰æ‹©ä¸‹æ‹‰æ¡† -->
                    <div class="relative" ref="modelDropdown">
                        <button 
                            @click="toggleModelDropdown" 
                            class="bg-white bg-opacity-20 hover:bg-opacity-30 active:bg-opacity-40 text-white text-xs px-3 py-1.5 md:px-3 md:py-2 rounded-lg transition-all duration-200 backdrop-blur-sm flex items-center space-x-2 min-w-[80px] active:scale-95 shadow-sm hover:shadow-md"
                        >
                            <span>{{ getModelDisplayName(selectedModel) }}</span>
                            <svg class="w-3 h-3 transition-transform duration-200" :class="{ 'rotate-180': isModelDropdownOpen }" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                            </svg>
                        </button>
                        
                        <!-- ä¸‹æ‹‰é€‰é¡¹ -->
                        <transition
                            enter-active-class="transition-all duration-200 ease-out"
                            enter-from-class="opacity-0 transform -translate-y-2 scale-95"
                            enter-to-class="opacity-100 transform translate-y-0 scale-100"
                            leave-active-class="transition-all duration-150 ease-in"
                            leave-from-class="opacity-100 transform translate-y-0 scale-100"
                            leave-to-class="opacity-0 transform -translate-y-2 scale-95"
                        >
                            <div v-if="isModelDropdownOpen" class="absolute top-full right-0 mt-2 bg-white rounded-xl shadow-2xl border border-gray-200 overflow-hidden z-[9999] min-w-[140px] backdrop-blur-sm">
                                <button 
                                    v-for="model in availableModels" 
                                    :key="model.id"
                                    @click="selectModel(model.id)"
                                    class="w-full text-left px-4 py-3 text-sm text-gray-700 hover:bg-gradient-to-r hover:from-purple-50 hover:to-purple-100 hover:text-purple-700 transition-all duration-200 flex items-center justify-between group border-l-4 border-transparent hover:border-purple-400 active:scale-[0.98]"
                                    :class="{ 'bg-gradient-to-r from-purple-100 to-purple-200 text-purple-800 border-l-4 border-purple-500': selectedModel === model.id }"
                                >
                                    <span class="font-medium">{{ model.name }}</span>
                                    <svg v-if="selectedModel === model.id" class="w-4 h-4 text-purple-600 transition-transform duration-200 group-hover:scale-110" fill="currentColor" viewBox="0 0 20 20">
                                        <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
                                    </svg>
                                </button>
                            </div>
                        </transition>
                    </div>
                    <!-- é‡æ–°å¼€å§‹æŒ‰é’® -->
                    <button @click="resetChat" class="text-xs bg-white bg-opacity-20 hover:bg-opacity-30 p-2 md:p-2.5 rounded-lg transition backdrop-blur-sm flex items-center justify-center">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg>
                    </button>
                </div>
            </div>
        </header>

        <!-- Chat Area -->
        <main class="flex-1 overflow-y-auto p-3 md:p-4 space-y-3 md:space-y-4 chat-container" ref="chatContainer">
            
            <!-- Welcome Message -->
            <div class="flex justify-start message-bubble">
                <div class="flex items-start space-x-2 md:space-x-3 max-w-[90%] md:max-w-[85%]">
                    <!-- AIå¤´åƒ -->
                    <div class="w-8 h-8 md:w-10 md:h-10 bg-white border-2 border-purple-300 rounded-full flex items-center justify-center flex-shrink-0 shadow-md avatar-glow">
                        <span class="text-lg md:text-xl">ğŸ©º</span>
                    </div>
                    <!-- æ¶ˆæ¯æ°”æ³¡ -->
                    <div class="bg-white p-3 md:p-4 rounded-2xl rounded-tl-sm shadow-sm border border-gray-100">
                        <p class="text-gray-700 leading-relaxed text-sm md:text-base">
                            <span class="text-lg md:text-xl mr-1">ğŸ‘‹</span>
                            æ‚¨å¥½ï¼æˆ‘æ˜¯æ‚¨çš„å¥åº·åŠ©æ‰‹ã€‚è¯·å‘Šè¯‰æˆ‘æ‚¨å“ªé‡Œä¸èˆ’æœï¼Ÿ
                        </p>
                        <p class="text-xs text-gray-400 mt-2">ä¾‹å¦‚ï¼šå¤´ç—›ã€å‘çƒ§ã€è…¹ç—›ç­‰</p>
                    </div>
                </div>
            </div>

            <!-- Chat History -->
            <div v-for="(msg, index) in displayMessages" :key="index" 
                 :class="['flex message-bubble', msg.role === 'user' ? 'justify-end' : 'justify-start']">
                
                <!-- AIæ¶ˆæ¯å¸ƒå±€ -->
                <div v-if="msg.role === 'assistant'" class="flex items-start space-x-2 md:space-x-3 max-w-[90%] md:max-w-[85%]">
                    <!-- AIå¤´åƒ -->
                    <div class="w-8 h-8 md:w-10 md:h-10 bg-white border-2 border-purple-300 rounded-full flex items-center justify-center flex-shrink-0 shadow-md avatar-glow">
                        <span class="text-lg md:text-xl">ğŸ©º</span>
                    </div>
                    <!-- æ¶ˆæ¯æ°”æ³¡ -->
                    <div class="bg-white p-3 md:p-4 rounded-2xl rounded-tl-sm shadow-sm border border-gray-100 flex-1">
                        <!-- AIæ¶ˆæ¯å†…å®¹ -->
                        <div v-if="msg.content">
                            <p class="text-gray-700 leading-relaxed text-sm md:text-base">
                                <span class="text-lg md:text-xl mr-1">{{ getMessageEmoji(msg, index) }}</span>
                                <span v-html="formatMessage(msg.content)"></span>
                            </p>
                        </div>
                        
                        <!-- é€‰é¡¹æ ‡ç­¾ -->
                        <div v-if="msg.options && msg.options.length > 0" class="mt-3 md:mt-4">
                            <p class="text-xs text-gray-500 mb-2 md:mb-3 flex items-center">
                                <svg class="w-3 h-3 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"></path></svg>
                                è¯·é€‰æ‹©ç›¸å…³ç—‡çŠ¶ï¼ˆå¯å¤šé€‰ï¼‰ï¼Œå¯ä¹Ÿæ‰“å­—æè¿°ç—‡çŠ¶ã€‚
                            </p>
                            <div class="flex flex-wrap gap-1.5 md:gap-2">
                                <button 
                                    v-for="option in msg.options" 
                                    :key="option"
                                    @click="toggleOption(msg, option)"
                                    :class="[
                                        'px-3 md:px-4 py-1.5 md:py-2 rounded-xl text-xs md:text-sm border-2 transition-all cursor-pointer font-medium',
                                        msg.selectedOptions && msg.selectedOptions.includes(option)
                                            ? 'bg-purple-600 text-white border-purple-600 shadow-md' 
                                            : 'bg-gray-50 text-gray-600 border-gray-200 hover:border-purple-600 hover:bg-purple-50'
                                    ]"
                                    :disabled="isRecording"
                                >
                                    {{ option }}
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- ç”¨æˆ·æ¶ˆæ¯å¸ƒå±€ -->
                <div v-else class="flex justify-end max-w-[90%] md:max-w-[85%]">
                    <!-- æ¶ˆæ¯æ°”æ³¡ -->
                    <div class="bg-gradient-to-r from-yellow-25 to-amber-25 text-gray-700 p-3 md:p-4 rounded-2xl rounded-tr-sm shadow-md flex-1 border border-yellow-100" style="background: linear-gradient(to right, #fefce8, #fffbeb);">
                        <!-- å›¾ç‰‡é¢„è§ˆ -->
                        <div v-if="msg.images && msg.images.length > 0" class="mb-2 space-y-2">
                            <div v-for="(img, imgIndex) in msg.images" :key="imgIndex" class="relative">
                                <img 
                                    :src="`data:${img.mime_type};base64,${img.base64}`"
                                    class="rounded-lg max-w-full h-auto max-h-64 object-contain border border-yellow-200 cursor-pointer hover:opacity-90 transition"
                                    alt="ä¸Šä¼ çš„å›¾ç‰‡"
                                    @click="previewImage(`data:${img.mime_type};base64,${img.base64}`)"
                                />
                            </div>
                        </div>
                        <!-- æ–‡å­—å†…å®¹ -->
                        <p class="leading-relaxed text-sm md:text-base">{{ msg.displayText || msg.content }}</p>
                    </div>
                </div>
            </div>

            <!-- Loading Indicator -->
            <div v-if="isLoading" class="flex justify-start message-bubble">
                <div class="flex items-start space-x-2 md:space-x-3 max-w-[90%] md:max-w-[85%]">
                    <!-- AIå¤´åƒ -->
                    <div class="w-8 h-8 md:w-10 md:h-10 bg-white border-2 border-purple-300 rounded-full flex items-center justify-center flex-shrink-0 shadow-md avatar-glow">
                        <span class="text-lg md:text-xl">ğŸ©º</span>
                    </div>
                    <!-- åŠ è½½åŠ¨ç”» -->
                    <div class="bg-white p-3 md:p-4 rounded-2xl rounded-tl-sm shadow-sm border border-gray-100">
                        <div class="flex items-center space-x-1">
                            <div class="w-2 h-2 bg-purple-600 rounded-full animate-bounce"></div>
                            <div class="w-2 h-2 bg-purple-600 rounded-full animate-bounce" style="animation-delay: 0.1s"></div>
                            <div class="w-2 h-2 bg-purple-600 rounded-full animate-bounce" style="animation-delay: 0.2s"></div>
                            <span class="text-xs text-gray-400 ml-2">æ­£åœ¨åˆ†æä¸­...</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Diagnosis Result Card -->
            <div v-if="diagnosis" class="mt-6 p-4 bg-purple-100 border border-purple-300 rounded-xl shadow-sm animate-fade-in">
                <h2 class="text-lg font-bold text-purple-900 mb-3 flex items-center">
                    <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    å¥åº·å»ºè®®
                </h2>
                
                <div class="space-y-3 text-sm">
                    <div>
                        <span class="font-semibold text-gray-700">å¯èƒ½æƒ…å†µï¼š</span>
                        <div class="flex flex-wrap gap-2 mt-1">
                            <span v-for="cond in diagnosis.possible_conditions" :key="cond" class="bg-purple-200 text-purple-900 px-2 py-1 rounded text-xs border border-purple-300">
                                {{ cond }}
                            </span>
                        </div>
                    </div>
                    
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <span class="font-semibold text-gray-700">å»ºè®®ç§‘å®¤ï¼š</span>
                            <p class="text-purple-800 font-bold mt-1">{{ diagnosis.department }}</p>
                        </div>
                        <div>
                            <span class="font-semibold text-gray-700">ç´§æ€¥ç¨‹åº¦ï¼š</span>
                            <p :class="['font-bold mt-1', getUrgencyColor(diagnosis.urgency)]">
                                {{ diagnosis.urgency }}
                            </p>
                        </div>
                    </div>

                    <div>
                        <span class="font-semibold text-gray-700">åŒ»ç–—å»ºè®®ï¼š</span>
                        <p class="mt-1 text-gray-600 leading-relaxed">{{ diagnosis.advice }}</p>
                    </div>

                    <!-- æ¨ç†æ­¥éª¤å¯è§†åŒ– -->
                    <div v-if="diagnosis.reasoning_steps && diagnosis.reasoning_steps.length > 0" class="mt-4">
                        <span class="font-semibold text-gray-700 mb-3 block">è¯Šæ–­æ¨ç†è¿‡ç¨‹ï¼š</span>
                        <div class="relative">
                            <!-- è¿æ¥çº¿ -->
                            <div class="absolute left-6 top-8 bottom-0 w-0.5 bg-purple-300"></div>
                            
                            <!-- æ¨ç†æ­¥éª¤ -->
                            <div v-for="(step, index) in diagnosis.reasoning_steps" :key="step.step" 
                                 class="relative flex items-start mb-6 last:mb-0">
                                <!-- æ­¥éª¤åœ†ç‚¹ -->
                                <div class="flex-shrink-0 w-12 h-12 rounded-full flex items-center justify-center z-10"
                                     :class="getStepTypeColor(step.type)">
                                    <span class="text-white font-bold text-sm">{{ step.step }}</span>
                                </div>
                                
                                <!-- æ­¥éª¤å†…å®¹ -->
                                <div class="ml-4 flex-1 bg-white border rounded-xl p-4 shadow-sm"
                                     :class="getStepBorderColor(step.type)">
                                    <h4 class="font-semibold text-gray-800 mb-2">{{ step.title }}</h4>
                                    <p class="text-gray-600 text-sm leading-relaxed">{{ step.content }}</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- æ¡‘åŸºå›¾å¯è§†åŒ– -->
                    <div v-if="diagnosis.sankey_data" class="mt-4">
                        <span class="font-semibold text-gray-700 mb-3 block">ç—‡çŠ¶-ç–¾ç—…å…³è”åˆ†æï¼š</span>
                        <div class="bg-white border rounded-xl p-4 shadow-sm">
                            <div id="sankeyChart" style="width: 100%; height: 400px;"></div>
                        </div>
                    </div>

                    <div class="pt-3 mt-3 border-t border-teal-200 text-xs text-gray-500 italic">
                        æœ¬ç»“æœç”± AI ç”Ÿæˆï¼Œä»…ä¾›å‚è€ƒï¼Œä¸èƒ½æ›¿ä»£åŒ»ç”Ÿé¢è¯Šã€‚å¦‚é‡æ€¥ç—‡è¯·ç«‹å³æ‹¨æ‰“æ€¥æ•‘ç”µè¯ã€‚
                    </div>
                </div>
            </div>

        </main>

        <!-- è¯­éŸ³å½•éŸ³å…‰æ™•å’Œæ³¢æµªåŠ¨ç”» -->
        <transition name="fade">
            <div v-if="isRecording">
                <!-- ç´«è‰²æ¸å˜å…‰æ™• -->
                <div class="voice-glow"></div>
                <!-- æ³¢æµªéŸ³é¢‘åŠ¨ç”» -->
                <div class="audio-wave">
                    <div class="audio-wave-bar"></div>
                    <div class="audio-wave-bar"></div>
                    <div class="audio-wave-bar"></div>
                    <div class="audio-wave-bar"></div>
                    <div class="audio-wave-bar"></div>
                </div>
            </div>
        </transition>

        <!-- å›¾ç‰‡é¢„è§ˆæ¨¡æ€æ¡† -->
        <transition name="fade">
            <div v-if="previewImageUrl" @click="closeImagePreview" class="fixed inset-0 bg-black bg-opacity-90 z-[9999] flex items-center justify-center p-4">
                <div class="relative max-w-full max-h-full">
                    <img :src="previewImageUrl" class="max-w-full max-h-[90vh] object-contain rounded-lg" alt="é¢„è§ˆå›¾ç‰‡" />
                    <button @click="closeImagePreview" class="absolute top-4 right-4 bg-white bg-opacity-20 hover:bg-opacity-30 text-white p-2 rounded-full transition">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
            </div>
        </transition>

        <!-- Input Area -->
        <footer class="flex-shrink-0 bg-white p-3 md:p-4 border-t border-gray-100 shadow-lg">
            <!-- å›¾ç‰‡é¢„è§ˆåŒºåŸŸ -->
            <div v-if="pendingImages.length > 0" class="mb-3 flex flex-wrap gap-2">
                <div v-for="(img, index) in pendingImages" :key="index" class="relative group">
                    <img 
                        :src="`data:${img.mime_type};base64,${img.base64}`"
                        class="w-20 h-20 object-cover rounded-lg border-2 border-purple-300"
                        :alt="img.name"
                    />
                    <button 
                        @click="removeImage(index)"
                        class="absolute -top-2 -right-2 bg-red-500 hover:bg-red-600 text-white rounded-full w-6 h-6 flex items-center justify-center shadow-lg transition opacity-0 group-hover:opacity-100"
                    >
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
            </div>
            
            <!-- æ˜¾ç¤ºå½“å‰AIæ¶ˆæ¯çš„é€‰é¡¹æäº¤æŒ‰é’® -->
            <div v-if="hasCurrentOptions" class="mb-3">
                <div class="flex items-center justify-between bg-purple-100 p-3 rounded-xl">
                    <span class="text-sm text-purple-800 flex items-center">
                        <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                        å·²é€‰æ‹© <span class="font-bold mx-1">{{ getCurrentSelectedCount() }}</span> ä¸ªç—‡çŠ¶
                    </span>
                    <button 
                        @click="submitCurrentOptions"
                        :disabled="getCurrentSelectedCount() === 0 || isLoading"
                        class="bg-purple-600 hover:bg-purple-700 disabled:bg-gray-300 text-white px-5 py-2 rounded-xl text-sm font-medium transition btn-hover flex items-center space-x-1"
                    >
                        <span>ç¡®è®¤æäº¤</span>
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path></svg>
                    </button>
                </div>
            </div>
            
            <div class="flex space-x-2 md:space-x-3" v-if="!diagnosis">
                <button 
                    v-if="!inputMessage.trim() || isVoiceMode"
                    @click="handleCamera" 
                    class="bg-gray-100 hover:bg-gray-200 text-gray-600 p-2.5 md:p-3 rounded-xl transition flex items-center justify-center"
                    :disabled="isLoading"
                >
                    <svg class="w-5 h-5 md:w-6 md:h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 13a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
                </button>
                
                <!-- è¯­éŸ³æ¨¡å¼ï¼šæŒ‰ä¸‹è¯´è¯æŒ‰é’® -->
                <div v-if="isVoiceMode" class="flex-1 relative">
                    <button 
                        @mousedown="startRecording"
                        @mouseup="stopRecording"
                        @mouseleave="stopRecording"
                        @touchstart="startRecording"
                        @touchend="stopRecording"
                        class="w-full border-2 border-purple-300 rounded-xl px-3 md:px-4 py-2.5 md:py-3 text-sm md:text-base focus:outline-none transition bg-purple-50 hover:bg-purple-100 active:bg-purple-200 active:scale-95 flex items-center justify-center space-x-2"
                        :disabled="isLoading"
                    >
                        <svg class="w-5 h-5 md:w-6 md:h-6 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 18.75a6 6 0 006-6v-1.5m-6 7.5a6 6 0 01-6-6v-1.5m6 7.5v3.75m-3.75 0h7.5M12 15.75a3 3 0 01-3-3V4.5a3 3 0 116 0v8.25a3 3 0 01-3 3z"></path></svg>
                        <span class="text-purple-700 font-medium">{{ isRecording ? 'æ­£åœ¨å½•éŸ³...' : 'æŒ‰ä¸‹è¯´è¯' }}</span>
                    </button>
                </div>
                
                <!-- é”®ç›˜æ¨¡å¼ï¼šè¾“å…¥æ¡† -->
                <div v-else class="flex-1 relative">
                    <input 
                        v-model="inputMessage" 
                        @keyup.enter="sendMessage"
                        type="text" 
                        placeholder="è¯·æè¿°æ‚¨çš„ç—‡çŠ¶..." 
                        class="w-full border-2 border-gray-200 rounded-xl px-3 md:px-4 py-2.5 md:py-3 text-sm md:text-base focus:outline-none focus:border-purple-600 transition input-glow bg-gray-50 focus:bg-white"
                        :class="inputMessage.trim() ? 'pr-12 md:pr-14' : 'pr-2 md:pr-2'"
                        :disabled="isLoading"
                    >
                </div>
                
                <div v-if="!inputMessage.trim() || isVoiceMode" class="flex space-x-1">
                    <!-- è¯­éŸ³æ¨¡å¼æ˜¾ç¤ºé”®ç›˜æŒ‰é’®ï¼Œé”®ç›˜æ¨¡å¼æ˜¾ç¤ºè¯­éŸ³æŒ‰é’® -->
                    <button 
                        v-if="isVoiceMode"
                        @click="toggleVoiceMode" 
                        class="bg-gray-100 hover:bg-gray-200 text-gray-600 p-2.5 md:p-3 rounded-xl transition flex items-center justify-center"
                        :disabled="isLoading"
                    >
                        <svg class="w-5 h-5 md:w-6 md:h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>
                    </button>
                    <button 
                        v-else
                        @click="toggleVoiceMode" 
                        class="bg-gray-100 hover:bg-gray-200 text-gray-600 p-2.5 md:p-3 rounded-xl transition flex items-center justify-center"
                        :disabled="isLoading"
                    >
                        <svg class="w-5 h-5 md:w-6 md:h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"></path></svg>
                    </button>
                    <button 
                        @click="handleAdd" 
                        class="bg-gray-100 hover:bg-gray-200 text-gray-600 p-2.5 md:p-3 rounded-xl transition flex items-center justify-center"
                        :disabled="isLoading"
                    >
                        <svg class="w-5 h-5 md:w-6 md:h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg>
                    </button>
                </div>
                
                <button 
                    v-if="inputMessage.trim() && !isVoiceMode"
                    @click="sendMessage" 
                    class="bg-gradient-to-r from-purple-600 to-purple-700 hover:from-purple-700 hover:to-purple-800 text-white p-2.5 md:p-3 rounded-xl transition disabled:opacity-50 disabled:cursor-not-allowed btn-hover flex items-center justify-center"
                    :disabled="!inputMessage.trim() || isLoading"
                >
                    <svg class="w-5 h-5 md:w-6 md:h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 10l7-7m0 0l7 7m-7-7v18"></path></svg>
                </button>
            </div>
            <div v-else class="text-center">
                <button @click="resetChat" class="bg-gradient-to-r from-gray-100 to-gray-200 hover:from-gray-200 hover:to-gray-300 text-gray-700 px-6 py-3 rounded-xl font-medium transition w-full flex items-center justify-center space-x-2">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg>
                    <span>å¼€å§‹æ–°çš„é—®è¯Š</span>
                </button>
            </div>
        </footer>
    </div>

    <script>
        const { createApp, ref, nextTick, computed, watch, onMounted, onUnmounted } = Vue;

        createApp({
            setup() {
                const API_BASE = '/api';
                const inputMessage = ref('');
                const isLoading = ref(false);
                const isWaitingAI = ref(false); // æ˜¯å¦æ­£åœ¨ç­‰å¾…AIå“åº”ï¼ˆä¸å½±å“UIäº¤äº’ï¼‰
                const currentAIAbortController = ref(null); // ç”¨äºå–æ¶ˆAIè¯·æ±‚
                const diagnosis = ref(null);
                const isVoiceMode = ref(false); // æ–°å¢è¯­éŸ³æ¨¡å¼çŠ¶æ€
                const isRecording = ref(false); // å½•éŸ³çŠ¶æ€
                const isTTSEnabled = ref(true); // TTSå¼€å…³çŠ¶æ€
                const currentAudio = ref(null);  // å½“å‰æ’­æ”¾çš„éŸ³é¢‘å®ä¾‹
                const currentAudioUrl = ref(null);  // å½“å‰éŸ³é¢‘URLï¼Œç”¨äºæ¸…ç†
                const mediaRecorder = ref(null); // MediaRecorderå®ä¾‹
                const audioChunks = ref([]); // éŸ³é¢‘æ•°æ®å—
                
                // å›¾ç‰‡ç›¸å…³
                const previewImageUrl = ref(null); // é¢„è§ˆå›¾ç‰‡URL
                const pendingImages = ref([]); // å¾…å‘é€çš„å›¾ç‰‡åˆ—è¡¨
                
                // æµå¼è¯†åˆ«ç›¸å…³
                const streamingWs = ref(null); // WebSocketè¿æ¥
                const streamingText = ref(''); // å®æ—¶è¯†åˆ«æ–‡æœ¬
                const audioContext = ref(null); // éŸ³é¢‘ä¸Šä¸‹æ–‡
                const audioWorklet = ref(null); // éŸ³é¢‘å¤„ç†èŠ‚ç‚¹
                const wsConnecting = ref(false); // WebSocketè¿æ¥ä¸­æ ‡å¿—
                const preAuthorizedStream = ref(null); // æå‰ç”³è¯·çš„éº¦å…‹é£æµï¼ˆç”¨äºå¿«é€Ÿå¯åŠ¨å½•éŸ³ï¼‰
                
                // TTSçŠ¶æ€è¿½è¸ª
                const currentTTSContext = ref(null); // å½“å‰TTSçš„AudioContext
                const currentTTSReader = ref(null); // å½“å‰TTSçš„æµè¯»å–å™¨
                const isTTSPlaying = ref(false); // TTSæ˜¯å¦æ­£åœ¨æ’­æ”¾
                
                // åœæ­¢å½“å‰TTSæ’­æ”¾
                const stopTTS = () => {
                    console.log('ğŸ›‘ [TTS] åœæ­¢å½“å‰TTSæ’­æ”¾');
                    
                    // åœæ­¢æ—§ç‰ˆTTSï¼ˆAudioå…ƒç´ ï¼‰
                    if (currentAudio.value) {
                        console.log('ğŸ›‘ [TTS] åœæ­¢Audioå…ƒç´ æ’­æ”¾');
                        currentAudio.value.pause();
                        currentAudio.value.currentTime = 0;
                        currentAudio.value = null;
                    }
                    // æ¸…ç†éŸ³é¢‘URLå¯¹è±¡ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼
                    if (currentAudioUrl.value) {
                        URL.revokeObjectURL(currentAudioUrl.value);
                        currentAudioUrl.value = null;
                    }
                    
                    // åœæ­¢æµå¼TTSï¼ˆWeb Audio APIï¼‰
                    if (currentTTSReader.value) {
                        console.log('ğŸ›‘ [TTS] å–æ¶ˆæµå¼è¯»å–');
                        try {
                            currentTTSReader.value.cancel();
                        } catch (e) {
                            console.warn('å–æ¶ˆæµå¼è¯»å–å¤±è´¥:', e);
                        }
                        currentTTSReader.value = null;
                    }
                    
                    if (currentTTSContext.value) {
                        console.log('ğŸ›‘ [TTS] å…³é—­AudioContext');
                        try {
                            currentTTSContext.value.close();
                        } catch (e) {
                            console.warn('å…³é—­AudioContextå¤±è´¥:', e);
                        }
                        currentTTSContext.value = null;
                    }
                    
                    isTTSPlaying.value = false;
                };

                // æ¨¡å‹é€‰æ‹©çŠ¶æ€
                let defaultModel = 'grok-4-1-fast-non-reasoning';
                try {
                    defaultModel = localStorage.getItem('selectedModel') || defaultModel;
                } catch (e) {
                    console.warn('localStorage not available, using default model');
                }
                const selectedModel = ref(defaultModel);
                const isModelDropdownOpen = ref(false);
                const modelDropdown = ref(null);
                
                // å¯ç”¨æ¨¡å‹åˆ—è¡¨
                const availableModels = [
                    { id: 'grok-4-1-fast-non-reasoning', name: 'Grok' },
                    { id: 'doubao-seed-1-6-thinking-250715', name: 'è±†åŒ…' },
                    { id: 'deepseek-v3.2-exp', name: 'Deepseek' }
                ];
                
                // è·å–æ¨¡å‹æ˜¾ç¤ºåç§°
                const getModelDisplayName = (modelId) => {
                    const model = availableModels.find(m => m.id === modelId);
                    return model ? model.name : modelId;
                };
                
                // åˆ‡æ¢ä¸‹æ‹‰æ¡†æ˜¾ç¤ºçŠ¶æ€
                const toggleModelDropdown = () => {
                    isModelDropdownOpen.value = !isModelDropdownOpen.value;
                };
                
                // é€‰æ‹©æ¨¡å‹
                const selectModel = (modelId) => {
                    selectedModel.value = modelId;
                    isModelDropdownOpen.value = false;
                };
                
                // ç›‘å¬æ¨¡å‹é€‰æ‹©å˜åŒ–å¹¶ä¿å­˜åˆ°localStorage
                watch(selectedModel, (newModel) => {
                    try {
                        localStorage.setItem('selectedModel', newModel);
                    } catch (e) {
                        console.warn('Failed to save model to localStorage:', e);
                    }
                });
                
                // ç‚¹å‡»å¤–éƒ¨å…³é—­ä¸‹æ‹‰æ¡†
                const handleClickOutside = (event) => {
                    if (modelDropdown.value && !modelDropdown.value.contains(event.target)) {
                        isModelDropdownOpen.value = false;
                    }
                };
                
                // ç»„ä»¶æŒ‚è½½æ—¶æ·»åŠ ç‚¹å‡»å¤–éƒ¨ç›‘å¬
                // é¢„è¿æ¥ WebSocketï¼ˆä¼˜åŒ–ï¼šå‡å°‘50-200mså»¶è¿Ÿï¼‰
                const preConnectWebSocket = () => {
                    // é¿å…é‡å¤è¿æ¥
                    if (streamingWs.value || wsConnecting.value) {
                        console.log('â­ï¸  WebSocketå·²å­˜åœ¨æˆ–æ­£åœ¨è¿æ¥ï¼Œè·³è¿‡é¢„è¿æ¥');
                        return;
                    }
                    
                    wsConnecting.value = true;
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const wsUrl = `${protocol}//${window.location.host}/api/chat/streaming-asr`;
                    
                    try {
                        streamingWs.value = new WebSocket(wsUrl);
                        
                        streamingWs.value.onopen = () => {
                            console.log('ğŸ”— WebSocket é¢„è¿æ¥æˆåŠŸ');
                            wsConnecting.value = false;
                        };
                        
                        // è®¾ç½®æ¶ˆæ¯å¤„ç†ï¼ˆåªè®¾ç½®ä¸€æ¬¡ï¼Œæ‰€æœ‰å½•éŸ³ä¼šè¯å…±äº«ï¼‰
                        streamingWs.value.onmessage = (event) => {
                            try {
                                const data = JSON.parse(event.data);
                                console.log('ğŸ“¥ æ”¶åˆ°è¯†åˆ«ç»“æœ:', data, 'å½“å‰streamingText:', streamingText.value);
                                
                                if (data.type === 'partial' || data.type === 'final') {
                                    // ğŸ”‘ åªä¿å­˜æ–‡æœ¬ï¼Œä¸æ˜¾ç¤ºæ°”æ³¡
                                    const oldText = streamingText.value;
                                    streamingText.value = data.text;
                                    console.log(`ğŸ“ ${data.type === 'final' ? 'æœ€ç»ˆ' : 'ä¸´æ—¶'}è¯†åˆ«æ–‡æœ¬: "${oldText}" -> "${data.text}"`);
                                } else if (data.type === 'error') {
                                    console.error('âŒ è¯­éŸ³è¯†åˆ«é”™è¯¯:', data.message);
                                    streamingText.value = '';
                                } else if (data.type === 'done') {
                                    console.log('âœ… è¯†åˆ«å®Œæˆä¿¡å·ï¼Œå½“å‰æ–‡æœ¬:', streamingText.value);
                                }
                            } catch (error) {
                                console.error('âŒ è§£æWebSocketæ¶ˆæ¯é”™è¯¯:', error);
                            }
                        };
                        
                        streamingWs.value.onerror = (error) => {
                            console.error('âŒ WebSocket è¿æ¥é”™è¯¯:', error);
                            streamingText.value = '';
                        };
                        
                        streamingWs.value.onclose = () => {
                            console.log('ğŸ”Œ WebSocket è¿æ¥å…³é—­');
                            wsConnecting.value = false;
                            streamingWs.value = null;
                            // 3ç§’åè‡ªåŠ¨é‡è¿ï¼ˆä¿æŒè¿æ¥å¯ç”¨ï¼‰
                            setTimeout(() => {
                                if (!isRecording.value) {
                                    preConnectWebSocket();
                                }
                            }, 3000);
                        };
                    } catch (error) {
                        console.error('âŒ WebSocket åˆ›å»ºå¤±è´¥:', error);
                        wsConnecting.value = false;
                        streamingWs.value = null;
                    }
                };

                onMounted(() => {
                    document.addEventListener('click', handleClickOutside);
                    // é¡µé¢åŠ è½½åé¢„è¿æ¥ WebSocket
                    preConnectWebSocket();
                });
                
                // ç»„ä»¶å¸è½½æ—¶ç§»é™¤ç›‘å¬
                onUnmounted(() => {
                    document.removeEventListener('click', handleClickOutside);
                    // æ¸…ç† WebSocket è¿æ¥
                    if (streamingWs.value) {
                        streamingWs.value.close();
                        streamingWs.value = null;
                    }
                });
                
                // å­˜å‚¨å¯¹è¯å†å² (å‘é€ç»™åç«¯çš„æ ¼å¼)
                // æ ¼å¼: { role: 'user' | 'assistant', content: string }
                const history = ref([]);

                // æ˜¾ç¤ºåœ¨ç•Œé¢ä¸Šçš„æ¶ˆæ¯ (ä¸åŒ…å«ç³»ç»Ÿ prompt ç­‰)
                const displayMessages = computed(() => history.value);

                const chatContainer = ref(null);

                const scrollToBottom = async () => {
                    await nextTick();
                    if (chatContainer.value) {
                        chatContainer.value.scrollTop = chatContainer.value.scrollHeight;
                    }
                };

                const getUrgencyColor = (urgency) => {
                    if (!urgency) return 'text-gray-600';
                    if (urgency.includes('æ€¥è¯Š')) return 'text-rose-600';
                    if (urgency.includes('å°½å¿«')) return 'text-purple-600';
                    return 'text-violet-600';
                };

                const sendMessage = async () => {
                    // æ£€æŸ¥æ˜¯å¦æœ‰å†…å®¹æˆ–å›¾ç‰‡
                    if (!inputMessage.value.trim() && pendingImages.value.length === 0) return;

                    // ğŸ”‘ é˜²å¾¡1: å–æ¶ˆæ­£åœ¨è¿›è¡Œçš„AIè¯·æ±‚
                    if (currentAIAbortController.value) {
                        console.log('ğŸ›‘ å–æ¶ˆæ­£åœ¨è¿›è¡Œçš„AIè¯·æ±‚');
                        currentAIAbortController.value.abort();
                        currentAIAbortController.value = null;
                    }
                    
                    // ğŸ”‘ é˜²å¾¡2: åœæ­¢å½“å‰TTSæ’­æ”¾
                    stopTTS();
                    
                    // ğŸ”‘ é˜²å¾¡3: å¦‚æœæœ€åä¸€æ¡æ¶ˆæ¯æ˜¯AIä¸”æ­£åœ¨æ’­æ”¾TTSï¼Œæ’¤å›è¯¥æ¶ˆæ¯
                    const lastMsg = history.value[history.value.length - 1];
                    if (lastMsg && lastMsg.role === 'assistant' && isTTSPlaying.value) {
                        console.log('ğŸ›‘ æ’¤å›æ­£åœ¨æ’­æ”¾TTSçš„AIæ¶ˆæ¯');
                        history.value.pop();
                    }

                    const userMsg = inputMessage.value.trim() || 'è¯·çœ‹è¿™å¼ å›¾ç‰‡';
                    inputMessage.value = '';
                    
                    // æ„å»ºç”¨æˆ·æ¶ˆæ¯
                    const userMessage = {
                        role: 'user',
                        content: userMsg
                    };
                    
                    // å¦‚æœæœ‰å¾…å‘é€çš„å›¾ç‰‡ï¼Œæ·»åŠ åˆ°æ¶ˆæ¯ä¸­
                    if (pendingImages.value.length > 0) {
                        userMessage.images = [...pendingImages.value];
                        userMessage.displayText = userMsg;
                        pendingImages.value = []; // æ¸…ç©ºå¾…å‘é€åˆ—è¡¨
                    }
                    
                    // 1. æ·»åŠ ç”¨æˆ·æ¶ˆæ¯åˆ°ç•Œé¢
                    history.value.push(userMessage);
                    await scrollToBottom();
                    
                    isLoading.value = true;
                    isWaitingAI.value = true;

                    try {
                        // 2. è°ƒç”¨ /chat/next æ¥å£ï¼ˆæ”¯æŒå–æ¶ˆï¼‰
                        const abortController = new AbortController();
                        currentAIAbortController.value = abortController;
                        
                        const response = await fetch(`${API_BASE}/chat/next`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ 
                                history: history.value,
                                model: selectedModel.value 
                            }),
                            signal: abortController.signal
                        });
                        
                        const data = await response.json();
                        
                        // ğŸ”‘ å…³é”®ï¼šLLMå“åº”åç«‹å³å…³é—­loadingï¼Œä¸ç­‰TTS
                        isLoading.value = false;
                        isWaitingAI.value = false;
                        currentAIAbortController.value = null;

                        if (data.status === 'continue') {
                            // AI ç»§ç»­æé—®ï¼Œå¯èƒ½åŒ…å«é€‰é¡¹
                            const aiMessage = {
                                role: 'assistant',
                                content: data.question || data.content || '',
                                options: data.options || [],
                                selectedOptions: []
                            };
                            
                            // ä½¿ç”¨åè°ƒçš„TTSæ˜¾ç¤ºå‡½æ•°ï¼ˆä¸é˜»å¡UIï¼‰
                            await displayAIMessageWithTTS(aiMessage);
                        } else if (data.status === 'stop') {
                            // AI å†³å®šåœæ­¢æé—®ï¼Œå¼€å§‹è¯Šæ–­
                            await generateDiagnosis();
                        } else {
                            console.error('API Error:', data.message);
                            const errorMessage = 'æŠ±æ­‰ï¼Œç³»ç»Ÿå‡ºé”™äº†ï¼Œè¯·é‡è¯•ã€‚';
                            const errorAIMessage = { role: 'assistant', content: errorMessage };
                            
                            // ä½¿ç”¨åè°ƒçš„TTSæ˜¾ç¤ºå‡½æ•°æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯
                            await displayAIMessageWithTTS(errorAIMessage);
                        }

                    } catch (error) {
                        isLoading.value = false;
                        isWaitingAI.value = false;
                        currentAIAbortController.value = null;
                        
                        // å¦‚æœæ˜¯ç”¨æˆ·ä¸»åŠ¨å–æ¶ˆï¼Œä¸æ˜¾ç¤ºé”™è¯¯
                        if (error.name === 'AbortError') {
                            console.log('âœ… AIè¯·æ±‚å·²è¢«ç”¨æˆ·å–æ¶ˆ');
                            return;
                        }
                        
                        console.error('Network Error:', error);
                        
                        const errorMessage = 'ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ‚¨çš„ç½‘ç»œã€‚';
                        const errorAIMessage = { role: 'assistant', content: errorMessage };
                        
                        // ä½¿ç”¨åè°ƒçš„TTSæ˜¾ç¤ºå‡½æ•°æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯
                        await displayAIMessageWithTTS(errorAIMessage);
                    } finally {
                        await scrollToBottom();
                    }
                };

                const toggleOption = (message, option) => {
                    if (!message.selectedOptions) {
                        message.selectedOptions = [];
                    }
                    
                    const index = message.selectedOptions.indexOf(option);
                    if (index > -1) {
                        message.selectedOptions.splice(index, 1);
                    } else {
                        message.selectedOptions.push(option);
                    }
                };

                const submitSelectedOptions = async (message) => {
                    if (!message.selectedOptions || message.selectedOptions.length === 0) {
                        return;
                    }

                    // åœæ­¢å½“å‰TTSæ’­æ”¾
                    stopTTS();

                    const selectedText = message.selectedOptions.join('ã€');
                    
                    // æ·»åŠ ç”¨æˆ·é€‰æ‹©çš„é€‰é¡¹ä½œä¸ºæ¶ˆæ¯
                    history.value.push({ role: 'user', content: selectedText });
                    await scrollToBottom();
                    
                    // æ¸…ç©ºå½“å‰æ¶ˆæ¯çš„é€‰ä¸­çŠ¶æ€
                    message.selectedOptions = [];
                    
                    isLoading.value = true;
                    isWaitingAI.value = true;

                    try {
                        const abortController = new AbortController();
                        currentAIAbortController.value = abortController;
                        
                        const response = await fetch(`${API_BASE}/chat/next`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ 
                                history: history.value,
                                model: selectedModel.value 
                            }),
                            signal: abortController.signal
                        });
                        
                        const data = await response.json();
                        
                        // ğŸ”‘ å…³é”®ï¼šLLMå“åº”åç«‹å³å…³é—­loadingï¼Œä¸ç­‰TTS
                        isLoading.value = false;
                        isWaitingAI.value = false;
                        currentAIAbortController.value = null;

                        if (data.status === 'continue') {
                            const aiMessage = {
                                role: 'assistant',
                                content: data.question || data.content || '',
                                options: data.options || [],
                                selectedOptions: []
                            };
                            
                            // ä½¿ç”¨åè°ƒçš„TTSæ˜¾ç¤ºå‡½æ•°
                            await displayAIMessageWithTTS(aiMessage);
                        } else if (data.status === 'stop') {
                            await generateDiagnosis();
                        } else {
                            console.error('API Error:', data.message);
                            const errorMessage = 'æŠ±æ­‰ï¼Œç³»ç»Ÿå‡ºé”™äº†ï¼Œè¯·é‡è¯•ã€‚';
                            const errorAIMessage = { role: 'assistant', content: errorMessage };
                            
                            // ä½¿ç”¨åè°ƒçš„TTSæ˜¾ç¤ºå‡½æ•°æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯
                            await displayAIMessageWithTTS(errorAIMessage);
                        }

                    } catch (error) {
                        isLoading.value = false;
                        isWaitingAI.value = false;
                        currentAIAbortController.value = null;
                        
                        // å¦‚æœæ˜¯ç”¨æˆ·ä¸»åŠ¨å–æ¶ˆï¼Œä¸æ˜¾ç¤ºé”™è¯¯
                        if (error.name === 'AbortError') {
                            console.log('âœ… AIè¯·æ±‚å·²è¢«ç”¨æˆ·å–æ¶ˆ');
                            return;
                        }
                        
                        console.error('Network Error:', error);
                        
                        const errorMessage = 'ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ‚¨çš„ç½‘ç»œã€‚';
                        const errorAIMessage = { role: 'assistant', content: errorMessage };
                        await displayAIMessageWithTTS(errorAIMessage);
                    } finally {
                        await scrollToBottom();
                    }
                };

                const getMessageEmoji = (msg, index) => {
                    if (msg.role === 'assistant') {
                        // æ ¹æ®æ¶ˆæ¯å†…å®¹é€‰æ‹©åˆé€‚çš„emoji
                        const content = msg.content || '';
                        if (content.includes('ç†è§£') || content.includes('æ‹…å¿ƒ')) return 'ğŸ¤—';
                        if (content.includes('æ„Ÿè°¢')) return 'ğŸ˜Š';
                        if (content.includes('è¯·é—®') || content.includes('èƒ½å‘Šè¯‰æˆ‘')) return 'ğŸ¤”';
                        if (content.includes('ç–¼ç—›') || content.includes('ä¸èˆ’æœ')) return 'ğŸ˜Ÿ';
                        if (content.includes('ä¸¥é‡') || content.includes('ç´§æ€¥')) return 'âš ï¸';
                        if (index === 0) return 'ğŸ‘‹'; // ç¬¬ä¸€æ¡AIæ¶ˆæ¯
                        return 'ğŸ’¬'; // é»˜è®¤å¯¹è¯emoji
                    }
                    return '';
                };

                const getUserEmoji = (msg) => {
                    const content = msg.content || '';
                    if (content.includes('ç–¼ç—›') || content.includes('ç—›')) return 'ğŸ˜£';
                    if (content.includes('å‘çƒ§') || content.includes('çƒ­')) return 'ğŸŒ¡ï¸';
                    if (content.includes('å’³å—½') || content.includes('å’³')) return 'ğŸ˜·';
                    if (content.includes('æ¶å¿ƒ') || content.includes('å')) return 'ğŸ¤¢';
                    if (content.includes('å¤´æ™•') || content.includes('æ™•')) return 'ğŸ˜µ';
                    return 'ğŸ—£ï¸'; // é»˜è®¤ç”¨æˆ·è¯´è¯emoji
                };

                const getOptionEmoji = (option) => {
                    // ä¸ºå¸¸è§ç—‡çŠ¶æ·»åŠ ç›¸å…³emoji
                    if (option.includes('å‘çƒ­') || option.includes('å‘çƒ§')) return 'ğŸŒ¡ï¸';
                    if (option.includes('å¤´ç—›') || option.includes('å¤´ç–¼')) return 'ğŸ¤•';
                    if (option.includes('å’³å—½')) return 'ğŸ˜·';
                    if (option.includes('æ¶å¿ƒ') || option.includes('å‘•å')) return 'ğŸ¤¢';
                    if (option.includes('è…¹æ³»') || option.includes('æ‹‰è‚šå­')) return 'ğŸš½';
                    if (option.includes('èƒ¸ç—›') || option.includes('èƒ¸é—·')) return 'ğŸ’”';
                    if (option.includes('è…¹ç—›') || option.includes('è‚šå­ç—›')) return 'ğŸ¤°';
                    if (option.includes('ä¹åŠ›') || option.includes('ç–²åŠ³')) return 'ğŸ˜´';
                    if (option.includes('é£Ÿæ¬²') || option.includes('åƒé¥­')) return 'ğŸ½ï¸';
                    return 'ğŸ·ï¸'; // é»˜è®¤é€‰é¡¹æ ‡ç­¾emoji
                };

                const formatMessage = (content) => {
                    // ç®€å•çš„æ¢è¡Œå¤„ç†
                    return content.replace(/\n/g, '<br>');
                };

                const generateDiagnosis = async () => {
                    // æ˜¾ç¤ºæ­£åœ¨ç”Ÿæˆè¯Šæ–­...
                    // è¿™é‡Œæˆ‘ä»¬ä¿æŒ isLoading ä¸º true
                    try {
                        const response = await fetch(`${API_BASE}/chat/diagnose`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ 
                                history: history.value,
                                model: selectedModel.value 
                            })
                        });
                        const result = await response.json();
                        diagnosis.value = result;
                        
                        // ä¸ºäº† UI å®Œæ•´ï¼Œä¹Ÿå¯ä»¥æŠŠè¯Šæ–­ç»“æœä½œä¸ºä¸€æ¡æ¶ˆæ¯å­˜å…¥ historyï¼Œæˆ–è€…åªæ˜¾ç¤ºå¡ç‰‡
                        // è¿™é‡Œé€‰æ‹©åªæ˜¾ç¤ºå¡ç‰‡
                    } catch (error) {
                        console.error('âŒ è¯Šæ–­æŠ¥å‘Šç”Ÿæˆå¤±è´¥:', error);
                        // é™é»˜å¤„ç†ï¼Œä¸å¼¹çª—æ‰“æ‰°ç”¨æˆ·
                    }
                };

                const resetChat = () => {
                    if (confirm('ç¡®å®šè¦æ¸…é™¤å½“å‰å¯¹è¯é‡æ–°å¼€å§‹å—ï¼Ÿ')) {
                        // å–æ¶ˆæ­£åœ¨è¿›è¡Œçš„AIè¯·æ±‚
                        if (currentAIAbortController.value) {
                            currentAIAbortController.value.abort();
                            currentAIAbortController.value = null;
                        }
                        
                        // åœæ­¢TTS
                        stopTTS();
                        
                        history.value = [];
                        diagnosis.value = null;
                        inputMessage.value = '';
                        isLoading.value = false;
                        isWaitingAI.value = false;
                    }
                };

                // å›¾ç‰‡é¢„è§ˆå’Œå…³é—­
                const previewImage = (url) => {
                    previewImageUrl.value = url;
                };
                
                const closeImagePreview = () => {
                    previewImageUrl.value = null;
                };
                
                // ç§»é™¤å¾…å‘é€çš„å›¾ç‰‡
                const removeImage = (index) => {
                    pendingImages.value.splice(index, 1);
                };
                
                // å¤„ç†å›¾ç‰‡é€‰æ‹©ï¼ˆé€šç”¨å‡½æ•°ï¼‰
                const handleImageSelection = async (file) => {
                    if (!file) return;
                    
                    // æ£€æŸ¥æ–‡ä»¶å¤§å°ï¼ˆé™åˆ¶5MBï¼‰
                    if (file.size > 5 * 1024 * 1024) {
                        alert('å›¾ç‰‡å¤§å°ä¸èƒ½è¶…è¿‡5MB');
                        return;
                    }
                    
                    console.log('ğŸ“¸ é€‰æ‹©äº†å›¾ç‰‡:', file.name, file.type, file.size);
                    
                    try {
                        // è¯»å–å›¾ç‰‡ä¸ºbase64
                        const reader = new FileReader();
                        const base64 = await new Promise((resolve, reject) => {
                            reader.onload = () => {
                                const result = reader.result;
                                const base64Data = result.split(',')[1];
                                resolve(base64Data);
                            };
                            reader.onerror = reject;
                            reader.readAsDataURL(file);
                        });
                        
                        // æ·»åŠ åˆ°å¾…å‘é€åˆ—è¡¨
                        pendingImages.value.push({
                            base64: base64,
                            mime_type: file.type,
                            name: file.name
                        });
                        
                        console.log('ğŸ“¸ å›¾ç‰‡å·²æ·»åŠ åˆ°å¾…å‘é€åˆ—è¡¨');
                        
                    } catch (error) {
                        console.error('âŒ å›¾ç‰‡å¤„ç†å¤±è´¥:', error);
                        alert('å›¾ç‰‡å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•');
                    }
                };
                
                // ç›¸æœºæŒ‰é’®ï¼šè°ƒç”¨æ‘„åƒå¤´æ‹ç…§
                const handleCamera = () => {
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = 'image/*';
                    input.capture = 'environment'; // ç§»åŠ¨ç«¯è°ƒç”¨æ‘„åƒå¤´ï¼ˆä¼˜å…ˆåç½®æ‘„åƒå¤´ï¼‰
                    input.multiple = false;
                    
                    input.onchange = async (e) => {
                        await handleImageSelection(e.target.files[0]);
                    };
                    
                    input.click();
                };

                const toggleVoiceMode = async () => {
                    isVoiceMode.value = !isVoiceMode.value;
                    if (isVoiceMode.value) {
                        // è¿›å…¥è¯­éŸ³æ¨¡å¼ï¼Œæ¸…ç©ºè¾“å…¥æ¡†
                        inputMessage.value = '';
                        
                        // ğŸ”‘ æå‰ç”³è¯·éº¦å…‹é£æƒé™ï¼Œè®©åç»­å½•éŸ³æ›´æµç•…
                        if (!preAuthorizedStream.value) {
                            try {
                                console.log('ğŸ¤ æå‰ç”³è¯·éº¦å…‹é£æƒé™...');
                                const stream = await navigator.mediaDevices.getUserMedia({ 
                                    audio: {
                                        sampleRate: 16000,
                                        channelCount: 1,
                                        echoCancellation: true,
                                        noiseSuppression: true
                                    }
                                });
                                preAuthorizedStream.value = stream;
                                console.log('âœ… éº¦å…‹é£æƒé™å·²è·å–ï¼Œå¯ä»¥éšæ—¶å¼€å§‹å½•éŸ³');
                            } catch (error) {
                                console.error('âŒ éº¦å…‹é£æƒé™ç”³è¯·å¤±è´¥:', error);
                                // ä¸é˜»æ­¢ç”¨æˆ·è¿›å…¥è¯­éŸ³æ¨¡å¼ï¼Œç­‰æŒ‰ä¸‹è¯´è¯æ—¶å†ç”³è¯·
                            }
                        }
                    } else {
                        // é€€å‡ºè¯­éŸ³æ¨¡å¼æ—¶ï¼Œé‡Šæ”¾æå‰ç”³è¯·çš„stream
                        if (preAuthorizedStream.value) {
                            preAuthorizedStream.value.getTracks().forEach(track => track.stop());
                            preAuthorizedStream.value = null;
                            console.log('ğŸ”Œ å·²é‡Šæ”¾æå‰ç”³è¯·çš„éº¦å…‹é£æµ');
                        }
                    }
                };

                // å½•éŸ³å¼€å§‹æ—¶é—´ï¼ˆç”¨äºæ£€æµ‹å½•éŸ³æ—¶é•¿ï¼‰
                const recordingStartTime = ref(0);
                const MIN_RECORDING_DURATION = 500; // æœ€å°å½•éŸ³æ—¶é•¿ï¼ˆæ¯«ç§’ï¼‰
                
                // ğŸ”‘ ç”¨äºå¤„ç†å¿«é€Ÿæ¾å¼€çš„æ ‡è®°
                const shouldStopRecording = ref(false);
                const stopRecordingTimer = ref(null);
                
                const startRecording = async () => {
                    if (isRecording.value) return;
                    
                    // ğŸ”‘ é˜²å¾¡1: å–æ¶ˆæ­£åœ¨è¿›è¡Œçš„AIè¯·æ±‚
                    if (currentAIAbortController.value) {
                        console.log('ğŸ›‘ å–æ¶ˆæ­£åœ¨è¿›è¡Œçš„AIè¯·æ±‚');
                        currentAIAbortController.value.abort();
                        currentAIAbortController.value = null;
                        isWaitingAI.value = false;
                    }
                    
                    // ğŸ”‘ é˜²å¾¡2: åœæ­¢å½“å‰TTSæ’­æ”¾
                    stopTTS();
                    
                    // ğŸ”‘ é˜²å¾¡3: å¦‚æœæœ€åä¸€æ¡æ¶ˆæ¯æ˜¯AIä¸”æ­£åœ¨æ’­æ”¾TTSï¼Œæ’¤å›è¯¥æ¶ˆæ¯
                    const lastMsg = history.value[history.value.length - 1];
                    if (lastMsg && lastMsg.role === 'assistant' && isTTSPlaying.value) {
                        console.log('ğŸ›‘ æ’¤å›æ­£åœ¨æ’­æ”¾TTSçš„AIæ¶ˆæ¯');
                        history.value.pop();
                    }
                    
                    // ğŸ”‘ æ¸…é™¤ä¹‹å‰çš„åœæ­¢æ ‡è®°
                    shouldStopRecording.value = false;
                    if (stopRecordingTimer.value) {
                        clearTimeout(stopRecordingTimer.value);
                        stopRecordingTimer.value = null;
                    }
                    
                    // ğŸ”‘ è®°å½•å¼€å§‹æ—¶é—´
                    recordingStartTime.value = Date.now();
                    
                    // ğŸ”‘ æ¸…ç©ºä¸´æ—¶è¯†åˆ«æ–‡æœ¬
                    console.log('ğŸ§¹ æ¸…ç©ºè¯†åˆ«æ–‡æœ¬ï¼Œå½“å‰å€¼:', streamingText.value);
                    streamingText.value = '';
                    console.log('ğŸ§¹ æ¸…ç©ºåå€¼:', streamingText.value);
                    
                    try {
                        console.log('ğŸ¤ å¼€å§‹æµå¼å½•éŸ³è¯†åˆ«ï¼ŒWebSocketçŠ¶æ€:', streamingWs.value ? streamingWs.value.readyState : 'null');
                        
                        // æ£€æŸ¥ WebSocket çŠ¶æ€
                        const startAudioCapture = async () => {
                            console.log('âœ… WebSocket å·²å°±ç»ªï¼Œå¼€å§‹å½•éŸ³');
                            // å‘é€å¼€å§‹å‘½ä»¤
                            streamingWs.value.send(JSON.stringify({ action: 'start' }));
                            
                            // ğŸ”‘ ä¼˜å…ˆä½¿ç”¨æå‰ç”³è¯·çš„éº¦å…‹é£æµï¼Œå¦‚æœæ²¡æœ‰å†ç”³è¯·
                            let stream;
                            if (preAuthorizedStream.value) {
                                console.log('âš¡ ä½¿ç”¨æå‰ç”³è¯·çš„éº¦å…‹é£æµï¼Œé›¶å»¶è¿Ÿå¯åŠ¨');
                                stream = preAuthorizedStream.value;
                                // æ¸…ç©ºå¼•ç”¨ï¼Œå› ä¸ºstreamä¼šè¢«ç”¨äºå½•éŸ³
                                preAuthorizedStream.value = null;
                            } else {
                                console.log('ğŸ¤ ç”³è¯·æ–°çš„éº¦å…‹é£æƒé™...');
                                stream = await navigator.mediaDevices.getUserMedia({ 
                                    audio: {
                                        sampleRate: 16000,
                                        channelCount: 1,
                                        echoCancellation: true,
                                        noiseSuppression: true
                                    }
                                });
                            }
                            
                            // ä½¿ç”¨ AudioContext å¤„ç†éŸ³é¢‘
                            audioContext.value = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
                            const source = audioContext.value.createMediaStreamSource(stream);
                            
                            // åˆ›å»º ScriptProcessor æ¥è·å–éŸ³é¢‘æ•°æ®
                            const processor = audioContext.value.createScriptProcessor(4096, 1, 1);
                            
                            processor.onaudioprocess = (e) => {
                                if (!isRecording.value) return;
                                
                                const inputData = e.inputBuffer.getChannelData(0);
                                // è½¬æ¢ä¸º Int16Array (PCM)
                                const pcmData = new Int16Array(inputData.length);
                                for (let i = 0; i < inputData.length; i++) {
                                    const s = Math.max(-1, Math.min(1, inputData[i]));
                                    pcmData[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                                }
                                
                                // å‘é€éŸ³é¢‘æ•°æ®
                                if (streamingWs.value && streamingWs.value.readyState === WebSocket.OPEN) {
                                    streamingWs.value.send(pcmData.buffer);
                                }
                            };
                            
                            source.connect(processor);
                            processor.connect(audioContext.value.destination);
                            
                            // ä¿å­˜å¼•ç”¨ä»¥ä¾¿åœæ­¢æ—¶æ¸…ç†
                            audioWorklet.value = { stream, processor, source };
                            
                            // ğŸ”‘ å…³é”®ï¼šå½•éŸ³çœŸæ­£å¼€å§‹åæ‰è®¾ç½®çŠ¶æ€
                            isRecording.value = true;
                            console.log('ğŸ”´ æ­£åœ¨å½•éŸ³...');
                            
                            // ğŸ”‘ æ£€æŸ¥æ˜¯å¦åœ¨å½•éŸ³å¼€å§‹å‰å°±å·²ç»æ¾æ‰‹äº†
                            if (shouldStopRecording.value) {
                                console.log('âš¡ æ£€æµ‹åˆ°å¿«é€Ÿæ¾å¼€ï¼Œç«‹å³åœæ­¢å½•éŸ³');
                                // ç«‹å³è°ƒç”¨åœæ­¢é€»è¾‘
                                setTimeout(() => stopRecording(), 0);
                            }
                        };
                        
                        // å¦‚æœ WebSocket å·²è¿æ¥ï¼Œç«‹å³å¼€å§‹
                        if (streamingWs.value && streamingWs.value.readyState === WebSocket.OPEN) {
                            await startAudioCapture();
                        } else {
                            // WebSocket æœªè¿æ¥ï¼Œé‡æ–°å»ºç«‹è¿æ¥
                            console.log('â³ WebSocket æœªå°±ç»ªï¼Œæ­£åœ¨è¿æ¥...');
                            preConnectWebSocket();
                            
                            // ç­‰å¾…è¿æ¥æˆåŠŸ
                            const waitForConnection = setInterval(async () => {
                                if (streamingWs.value && streamingWs.value.readyState === WebSocket.OPEN) {
                                    clearInterval(waitForConnection);
                                    await startAudioCapture();
                                }
                            }, 50);
                            
                            // 3ç§’è¶…æ—¶
                            setTimeout(() => {
                                clearInterval(waitForConnection);
                                if (!isRecording.value) {
                                    console.error('âŒ WebSocketè¿æ¥è¶…æ—¶');
                                    streamingText.value = '';
                                }
                            }, 3000);
                        }
                        
                    } catch (error) {
                        console.error('âŒ æ— æ³•è®¿é—®éº¦å…‹é£:', error);
                        // é™é»˜å¤„ç†ï¼Œä¸å¼¹çª—æ‰“æ‰°ç”¨æˆ·
                        streamingText.value = '';
                    }
                };

                const stopRecording = async () => {
                    // ğŸ”‘ å¦‚æœå½•éŸ³è¿˜æ²¡çœŸæ­£å¼€å§‹ï¼Œè®¾ç½®æ ‡è®°ç­‰å¾…
                    if (!isRecording.value) {
                        console.log('â³ å½•éŸ³å°šæœªå¼€å§‹ï¼Œè®¾ç½®åœæ­¢æ ‡è®°');
                        shouldStopRecording.value = true;
                        
                        // ğŸ”‘ è®¾ç½®è¶…æ—¶ï¼šå¦‚æœ1ç§’åè¿˜æ²¡å¼€å§‹å½•éŸ³ï¼Œç›´æ¥æ¸…ç†
                        stopRecordingTimer.value = setTimeout(() => {
                            if (!isRecording.value && shouldStopRecording.value) {
                                console.log('â±ï¸  å½•éŸ³å¯åŠ¨è¶…æ—¶ï¼Œæ¸…ç†çŠ¶æ€');
                                shouldStopRecording.value = false;
                                streamingText.value = '';
                            }
                        }, 1000);
                        
                        return;
                    }
                    
                    // ğŸ”‘ æ£€æŸ¥å½•éŸ³æ—¶é•¿
                    const recordingDuration = Date.now() - recordingStartTime.value;
                    console.log(`â¸ï¸  åœæ­¢å½•éŸ³ (æ—¶é•¿: ${recordingDuration}ms)`);
                    
                    isRecording.value = false;
                    
                    // ğŸ”‘ å¦‚æœå½•éŸ³æ—¶é—´å¤ªçŸ­ï¼Œç›´æ¥å–æ¶ˆ
                    if (recordingDuration < MIN_RECORDING_DURATION) {
                        console.warn(`âš ï¸  å½•éŸ³æ—¶é—´è¿‡çŸ­ (${recordingDuration}ms < ${MIN_RECORDING_DURATION}ms)ï¼Œå·²å–æ¶ˆ`);
                        
                        try {
                            // æ¸…ç†éŸ³é¢‘èµ„æº
                            if (audioWorklet.value) {
                                audioWorklet.value.processor.disconnect();
                                audioWorklet.value.source.disconnect();
                                audioWorklet.value.stream.getTracks().forEach(track => track.stop());
                                audioWorklet.value = null;
                            }
                            
                            if (audioContext.value) {
                                await audioContext.value.close();
                                audioContext.value = null;
                            }
                            
                            streamingText.value = '';
                            console.log('âœ… å·²å–æ¶ˆçŸ­æ—¶å½•éŸ³');
                        } catch (error) {
                            console.error('æ¸…ç†èµ„æºé”™è¯¯:', error);
                        }
                        
                        return; // ç›´æ¥è¿”å›ï¼Œä¸ç»§ç»­å¤„ç†
                    }
                    
                    try {
                        // å‘é€åœæ­¢å‘½ä»¤
                        if (streamingWs.value && streamingWs.value.readyState === WebSocket.OPEN) {
                            streamingWs.value.send(JSON.stringify({ action: 'stop' }));
                        }
                        
                        // æ¸…ç†éŸ³é¢‘èµ„æº
                        if (audioWorklet.value) {
                            audioWorklet.value.processor.disconnect();
                            audioWorklet.value.source.disconnect();
                            audioWorklet.value.stream.getTracks().forEach(track => track.stop());
                            audioWorklet.value = null;
                        }
                        
                        if (audioContext.value) {
                            await audioContext.value.close();
                            audioContext.value = null;
                        }
                        
                        // ğŸ”‘ å¦‚æœè¿˜åœ¨è¯­éŸ³æ¨¡å¼ï¼Œé‡æ–°ç”³è¯·streamä»¥å¤‡ä¸‹æ¬¡ä½¿ç”¨ï¼ˆä¸ä¼šå¼¹å‡ºæƒé™è¯·æ±‚ï¼‰
                        if (isVoiceMode.value && !preAuthorizedStream.value) {
                            try {
                                console.log('ğŸ”„ é‡æ–°ç”³è¯·éº¦å…‹é£æµä»¥å¤‡ä¸‹æ¬¡ä½¿ç”¨...');
                                const stream = await navigator.mediaDevices.getUserMedia({ 
                                    audio: {
                                        sampleRate: 16000,
                                        channelCount: 1,
                                        echoCancellation: true,
                                        noiseSuppression: true
                                    }
                                });
                                preAuthorizedStream.value = stream;
                                console.log('âœ… å·²é‡æ–°ç”³è¯·éº¦å…‹é£æµï¼Œä¸‹æ¬¡å½•éŸ³é›¶å»¶è¿Ÿ');
                            } catch (error) {
                                console.warn('âš ï¸  é‡æ–°ç”³è¯·éº¦å…‹é£æµå¤±è´¥ï¼Œä¸‹æ¬¡å½•éŸ³æ—¶å†ç”³è¯·:', error);
                            }
                        }
                        
                        // ç­‰å¾…æœ€ç»ˆç»“æœ
                        setTimeout(async () => {
                            console.log('ğŸ” [500mså] æ£€æŸ¥è¯†åˆ«æ–‡æœ¬:', streamingText.value);
                            
                            const recognizedText = streamingText.value.trim();
                            console.log('ğŸ” [500mså] trimåçš„æ–‡æœ¬:', recognizedText, 'é•¿åº¦:', recognizedText.length);
                            
                            if (recognizedText) {
                                // ä½¿ç”¨è¯†åˆ«çš„æ–‡æœ¬ç»§ç»­å¯¹è¯
                                console.log('âœ… è¯†åˆ«å®Œæˆï¼Œå‡†å¤‡å‘é€:', recognizedText);
                                
                                // ğŸ”‘ æ¾æ‰‹ååˆ›å»ºè¯­éŸ³æ¶ˆæ¯æ°”æ³¡
                                const voiceMessage = {
                                    role: 'user',
                                    content: recognizedText,
                                    displayText: recognizedText,
                                    isVoice: true
                                };
                                history.value.push(voiceMessage);
                                await scrollToBottom();
                                
                                // ç›´æ¥è°ƒç”¨ AI å¯¹è¯
                                isLoading.value = true;
                                isWaitingAI.value = true;
                                
                                try {
                                    const abortController = new AbortController();
                                    currentAIAbortController.value = abortController;
                                    
                                    const response = await fetch(`${API_BASE}/chat/next`, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({
                                            history: history.value.map(msg => ({
                                                role: msg.role,
                                                content: msg.content || msg.displayText
                                            }))
                                        }),
                                        signal: abortController.signal
                                    });
                                    
                                    if (!response.ok) {
                                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                                    }
                                    
                                    const data = await response.json();
                                    console.log('ğŸ“¥ AI å“åº”æ•°æ®:', data);
                                    
                                    // ğŸ”‘ å…³é”®ï¼šLLMå“åº”åç«‹å³å…³é—­loadingï¼Œä¸ç­‰TTS
                                    isLoading.value = false;
                                    isWaitingAI.value = false;
                                    currentAIAbortController.value = null;
                                    
                                    if (data.question) {
                                        // æ„é€  AI æ¶ˆæ¯å¯¹è±¡ï¼ˆåŒ…å« optionsï¼‰
                                        const aiMessage = {
                                            role: 'assistant',
                                            content: data.question,
                                            options: data.options || [],
                                            selectedOptions: []
                                        };
                                        await displayAIMessageWithTTS(aiMessage);
                                    } else {
                                        console.warn('âš ï¸  AI æ²¡æœ‰è¿”å›é—®é¢˜');
                                    }
                                    
                                    if (data.diagnosis) {
                                        diagnosis.value = data.diagnosis;
                                        await scrollToBottom();
                                    }
                                } catch (error) {
                                    isLoading.value = false;
                                    isWaitingAI.value = false;
                                    currentAIAbortController.value = null;
                                    
                                    // å¦‚æœæ˜¯ç”¨æˆ·ä¸»åŠ¨å–æ¶ˆï¼Œä¸æ˜¾ç¤ºé”™è¯¯
                                    if (error.name === 'AbortError') {
                                        console.log('âœ… AIè¯·æ±‚å·²è¢«ç”¨æˆ·å–æ¶ˆ');
                                        // æ¸…ç†
                                        streamingText.value = '';
                                        return;
                                    }
                                    
                                    console.error('âŒ AI å“åº”é”™è¯¯:', error);
                                }
                                
                                // æ¸…ç†
                                streamingText.value = '';
                            } else {
                                console.warn('âš ï¸  æ²¡æœ‰è¯†åˆ«åˆ°æ–‡æœ¬ï¼Œè·³è¿‡ AI å¯¹è¯');
                                streamingText.value = '';
                            }
                            
                            // ä¿æŒ WebSocket è¿æ¥ï¼ˆä¸‹æ¬¡ä½¿ç”¨æ›´å¿«ï¼‰
                            console.log('âœ… ä¿æŒ WebSocket è¿æ¥ï¼Œä¸‹æ¬¡ä½¿ç”¨é›¶å»¶è¿Ÿ');
                        }, 500); // ç»™ä¸€ç‚¹æ—¶é—´æ¥æ”¶æœ€ç»ˆç»“æœ
                        
                    } catch (error) {
                        console.error('åœæ­¢å½•éŸ³é”™è¯¯:', error);
                    }
                };

                // åŠ å·æŒ‰é’®ï¼šä»å›¾åº“é€‰æ‹©å›¾ç‰‡
                const handleAdd = () => {
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = 'image/*';
                    // ä¸è®¾ç½® capture å±æ€§ï¼Œè®©ç”¨æˆ·ä»å›¾åº“é€‰æ‹©
                    input.multiple = false;
                    
                    input.onchange = async (e) => {
                        await handleImageSelection(e.target.files[0]);
                    };
                    
                    input.click();
                };

                // åè°ƒæ˜¾ç¤ºAIæ¶ˆæ¯å’Œæ’­æ”¾TTSï¼ˆçœŸæ­£çš„æµå¼ç‰ˆæœ¬ - ä½¿ç”¨Web Audio APIï¼‰
                const displayAIMessageWithTTS = async (aiMessage) => {
                    // ğŸ¯ çœŸæ­£çš„æµå¼æ’­æ”¾ï¼šæ”¶åˆ°ç¬¬ä¸€ä¸ªPCMåŒ…ç«‹å³å¼€å§‹æ’­æ”¾ï¼Œè¾¹æ’­æ”¾è¾¹æ¥æ”¶
                    
                    // ğŸ”‘ é˜²å¾¡1: æ£€æŸ¥æœ€åä¸€æ¡æ¶ˆæ¯ï¼Œé˜²æ­¢AIè¿ç»­å‘é€ä¸¤æ¡æ¶ˆæ¯
                    const lastMsg = history.value[history.value.length - 1];
                    if (lastMsg && lastMsg.role === 'assistant') {
                        console.warn('âš ï¸  æ£€æµ‹åˆ°AIè¿ç»­å‘é€æ¶ˆæ¯ï¼Œè·³è¿‡æœ¬æ¬¡æ¶ˆæ¯');
                        return;
                    }
                    
                    if (!isTTSEnabled.value) {
                        // TTSå…³é—­ï¼Œç›´æ¥æ˜¾ç¤ºæ–‡å­—
                        history.value.push(aiMessage);
                        await scrollToBottom();
                        console.log('ğŸ’¬ [TTSå…³é—­] AIæ¶ˆæ¯å·²æ˜¾ç¤º');
                        return;
                    }
                    
                    try {
                        console.log('ğŸ¤ [TTS] å¼€å§‹æµå¼TTSè¯·æ±‚...');
                        
                        // ğŸ”‘ æ ‡è®°TTSæ­£åœ¨æ’­æ”¾
                        isTTSPlaying.value = true;
                        
                        // 1. å‘èµ·æµå¼TTSè¯·æ±‚ï¼ˆPCMæ ¼å¼ï¼‰
                        const ttsResponse = await fetch('/api/chat/tts-stream', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ text: aiMessage.content })
                        });
                        
                        if (!ttsResponse.ok) {
                            console.error('TTSè¯·æ±‚å¤±è´¥:', ttsResponse.status);
                            history.value.push(aiMessage);
                            await scrollToBottom();
                            isTTSPlaying.value = false;
                            return;
                        }
                        
                        console.log('ğŸ¤ [TTS] å¼€å§‹æ¥æ”¶PCMéŸ³é¢‘æµ...');
                        
                        // 2. åˆ›å»ºWeb Audio APIä¸Šä¸‹æ–‡
                        const audioCtx = new (window.AudioContext || window.webkitAudioContext)({
                            sampleRate: 24000
                        });
                        
                        // ğŸ”‘ è¿½è¸ªå½“å‰çš„AudioContextå’ŒReaderï¼Œä»¥ä¾¿ä¸­æ–­
                        currentTTSContext.value = audioCtx;
                        
                        let firstChunkReceived = false;
                        let chunkCount = 0;
                        
                        // ğŸ”‘ å…³é”®ï¼šç”¨äºä¸²è”æ’­æ”¾çš„æ—¶é—´ç‚¹
                        let nextStartTime = audioCtx.currentTime;
                        
                        // 3. ä½¿ç”¨ReadableStreamé€å—æ¥æ”¶å¹¶ä¸²è”æ’­æ”¾PCMéŸ³é¢‘
                        const reader = ttsResponse.body.getReader();
                        
                        // ğŸ”‘ è¿½è¸ªReaderä»¥ä¾¿ä¸­æ–­
                        currentTTSReader.value = reader;
                        
                        while (true) {
                            const { done, value } = await reader.read();
                            
                            // ğŸ”‘ æ£€æŸ¥æ˜¯å¦è¢«ä¸­æ–­
                            if (!isTTSPlaying.value) {
                                console.log('ğŸ›‘ [TTS] æ£€æµ‹åˆ°ä¸­æ–­ä¿¡å·ï¼Œåœæ­¢æ’­æ”¾');
                                reader.cancel();
                                audioCtx.close();
                                return;
                            }
                            
                            if (value && value.length > 0) {
                                chunkCount++;
                                
                                // æ”¶åˆ°ç¬¬ä¸€ä¸ªéŸ³é¢‘å— - ç«‹å³æ˜¾ç¤ºæ–‡å­—æ°”æ³¡
                                if (!firstChunkReceived) {
                                    firstChunkReceived = true;
                                    console.log('âš¡ [TTS] æ”¶åˆ°é¦–ä¸ªPCMéŸ³é¢‘åŒ…ï¼Œç«‹å³æ˜¾ç¤ºæ–‡å­—å¹¶å¼€å§‹æ’­æ”¾');
                                    
                                    // æ˜¾ç¤ºAIæ¶ˆæ¯
                                    history.value.push(aiMessage);
                                    await scrollToBottom();
                                }
                                
                                // å°†PCMæ•°æ®è½¬æ¢ä¸ºAudioBufferå¹¶ä¸²è”æ’­æ”¾
                                try {
                                    // PCMæ˜¯16ä½å°ç«¯æ ¼å¼ï¼Œéœ€è¦è½¬æ¢ä¸ºFloat32
                                    const pcmData = new Int16Array(value.buffer);
                                    const floatData = new Float32Array(pcmData.length);
                                    
                                    for (let i = 0; i < pcmData.length; i++) {
                                        floatData[i] = pcmData[i] / 32768.0; // è½¬æ¢ä¸º[-1, 1]èŒƒå›´
                                    }
                                    
                                    // åˆ›å»ºAudioBuffer
                                    const audioBuffer = audioCtx.createBuffer(1, floatData.length, 24000);
                                    audioBuffer.getChannelData(0).set(floatData);
                                    
                                    // åˆ›å»ºéŸ³é¢‘æºå¹¶ä¸²è”æ’­æ”¾
                                    const source = audioCtx.createBufferSource();
                                    source.buffer = audioBuffer;
                                    source.connect(audioCtx.destination);
                                    
                                    // ğŸ”‘ å…³é”®ï¼šç¡®ä¿ä¸²è”æ’­æ”¾ï¼Œä¸é‡å 
                                    // å¦‚æœnextStartTimeå·²ç»è¿‡å»ï¼Œä»å½“å‰æ—¶é—´å¼€å§‹ï¼›å¦åˆ™ä»nextStartTimeå¼€å§‹
                                    const startTime = Math.max(nextStartTime, audioCtx.currentTime);
                                    source.start(startTime);
                                    
                                    // æ›´æ–°ä¸‹ä¸€ä¸ªéŸ³é¢‘å—çš„å¼€å§‹æ—¶é—´
                                    nextStartTime = startTime + audioBuffer.duration;
                                    
                                    console.log(`ğŸ”Š [TTS] ä¸²è”æ’­æ”¾éŸ³é¢‘å— #${chunkCount}: ${floatData.length}é‡‡æ ·ç‚¹, æ—¶é•¿${(audioBuffer.duration * 1000).toFixed(0)}ms`);
                                    
                                } catch (err) {
                                    console.error('æ’­æ”¾éŸ³é¢‘å—å¤±è´¥:', err);
                                }
                            }
                            
                            if (done) {
                                console.log('âœ… [TTS] éŸ³é¢‘æµæ¥æ”¶å®Œæˆ');
                                break;
                            }
                        }
                        
                        // å¦‚æœæ²¡æ”¶åˆ°ä»»ä½•éŸ³é¢‘æ•°æ®ä½†ä¹Ÿæ²¡æ˜¾ç¤ºæ–‡å­—ï¼Œè¡¥æ•‘æ˜¾ç¤º
                        if (!firstChunkReceived) {
                            console.warn('âš ï¸  [TTS] æœªæ”¶åˆ°éŸ³é¢‘æ•°æ®ï¼Œç›´æ¥æ˜¾ç¤ºæ–‡å­—');
                            history.value.push(aiMessage);
                            await scrollToBottom();
                        }
                        
                        // ç­‰å¾…æ‰€æœ‰éŸ³é¢‘æ’­æ”¾å®Œæˆåå…³é—­ä¸Šä¸‹æ–‡
                        const remainingTime = (nextStartTime - audioCtx.currentTime) * 1000;
                        if (remainingTime > 0) {
                            setTimeout(() => {
                                // åªæœ‰å½“å‰AudioContextè¿˜æ˜¯è¿™ä¸ªæ—¶æ‰å…³é—­ï¼ˆé¿å…å…³é—­æ–°çš„ï¼‰
                                if (currentTTSContext.value === audioCtx) {
                                    audioCtx.close();
                                    currentTTSContext.value = null;
                                    currentTTSReader.value = null;
                                    isTTSPlaying.value = false;
                                    console.log('âœ… [TTS] éŸ³é¢‘æ’­æ”¾å®Œæˆï¼Œå…³é—­AudioContext');
                                }
                            }, remainingTime + 100);
                        } else {
                            if (currentTTSContext.value === audioCtx) {
                                audioCtx.close();
                                currentTTSContext.value = null;
                                currentTTSReader.value = null;
                                isTTSPlaying.value = false;
                            }
                        }
                        
                    } catch (error) {
                        console.error('TTSåŠŸèƒ½å‡ºé”™:', error);
                        // æ¸…ç†å¼•ç”¨
                        if (currentTTSContext.value) {
                            try {
                                currentTTSContext.value.close();
                            } catch (e) {}
                            currentTTSContext.value = null;
                            currentTTSReader.value = null;
                        }
                        isTTSPlaying.value = false;
                        
                        // å‡ºé”™æ—¶ç¡®ä¿æ–‡å­—èƒ½æ˜¾ç¤º
                        if (!history.value.includes(aiMessage)) {
                            history.value.push(aiMessage);
                            await scrollToBottom();
                        }
                    }
                };

                const hasCurrentOptions = computed(() => {
                    const lastMessage = history.value[history.value.length - 1];
                    return lastMessage && 
                           lastMessage.role === 'assistant' && 
                           lastMessage.options && 
                           lastMessage.options.length > 0;
                });

                const getCurrentSelectedCount = () => {
                    const lastMessage = history.value[history.value.length - 1];
                    if (!lastMessage || !lastMessage.selectedOptions) return 0;
                    return lastMessage.selectedOptions.length;
                };

                const submitCurrentOptions = async () => {
                    const lastMessage = history.value[history.value.length - 1];
                    if (!lastMessage || !lastMessage.selectedOptions || lastMessage.selectedOptions.length === 0) {
                        return;
                    }
                    await submitSelectedOptions(lastMessage);
                };

                const getStepTypeColor = (type) => {
                    switch (type) {
                        case 'symptom':
                            return 'bg-purple-500';
                        case 'analysis':
                            return 'bg-violet-500';
                        case 'conclusion':
                            return 'bg-fuchsia-500';
                        default:
                            return 'bg-gray-500';
                    }
                };

                const getStepBorderColor = (type) => {
                    switch (type) {
                        case 'symptom':
                            return 'border-purple-200';
                        case 'analysis':
                            return 'border-violet-200';
                        case 'conclusion':
                            return 'border-fuchsia-200';
                        default:
                            return 'border-gray-200';
                    }
                };

                const renderSankeyChart = () => {
                    if (!diagnosis.value || !diagnosis.value.sankey_data) return;
                    
                    const chartDom = document.getElementById('sankeyChart');
                    if (!chartDom) return;
                    
                    const sankeyData = diagnosis.value.sankey_data;
                    
                    if (!sankeyData.nodes || !sankeyData.links) {
                        console.warn('Sankey data is incomplete');
                        return;
                    }

                    // åŠ¨æ€è®¡ç®—é«˜åº¦ï¼šæ¯ä¸ªèŠ‚ç‚¹è‡³å°‘ç»™60pxé«˜åº¦ï¼Œé˜²æ­¢æ‹¥æŒ¤
                    // æ‰¾å‡ºæ¯ä¸€å±‚èŠ‚ç‚¹æœ€å¤šçš„æ•°é‡
                    const layerCounts = [0, 0, 0];
                    sankeyData.nodes.forEach(n => {
                        if (n.layer >= 0 && n.layer <= 2) layerCounts[n.layer]++;
                    });
                    const maxNodes = Math.max(...layerCounts);
                    // åŸºç¡€é«˜åº¦600pxï¼Œæ¯å¢åŠ ä¸€ä¸ªèŠ‚ç‚¹å¢åŠ 80px
                    const calculatedHeight = Math.max(600, maxNodes * 100); 
                    chartDom.style.height = `${calculatedHeight}px`;

                    const myChart = echarts.init(chartDom);

                    // å®šä¹‰é¢œè‰²æ˜ å°„
                    const colors = {
                        'ç—‡çŠ¶': '#ec4899',     // ç²‰è‰²
                        'å‘ç—…æ—¶é—´': '#3b82f6', // è“è‰²
                        'éƒ¨ä½': '#f59e0b',     // æ©™è‰²
                        'åˆ†æ': '#8b5cf6',     // ç´«è‰²
                        'æ—¶é—´åˆ†æ': '#6366f1', // é›è“
                        'éƒ¨ä½åˆ†æ': '#d97706', // æ·±æ©™
                        'ç–‘ä¼¼æ‚£ç—…': '#10b981', // ç»¿è‰²
                        'å…¶ä»–': '#9ca3af'      // ç°è‰²
                    };

                    const getNodeColor = (category) => colors[category] || colors['å…¶ä»–'];

                    // åˆ¤æ–­æ˜¯å¦ç§»åŠ¨ç«¯
                    const isMobile = window.innerWidth < 768;
                    // è°ƒæ•´èŠ‚ç‚¹å®½åº¦ï¼šå˜çª„ä¸€äº›ï¼Œç•™å‡ºæ›´å¤šç©ºé—´ç»™è¿æ¥çº¿
                    const nodeWidth = isMobile ? 60 : 80; 

                    // è½¬æ¢èŠ‚ç‚¹æ•°æ®
                    const nodes = sankeyData.nodes.map(node => ({
                        name: node.name,
                        itemStyle: {
                            color: node.color || getNodeColor(node.category),
                            borderColor: '#fff',
                            borderWidth: 1,
                            opacity: 0.9
                        },
                        label: {
                            show: true,
                            position: 'inside', 
                            formatter: function(params) {
                                let name = node.name;
                                // ç®€å•çš„æ¢è¡Œé€»è¾‘ï¼šæ¯Nä¸ªå­—ç¬¦æ¢ä¸€è¡Œ
                                const charsPerRow = isMobile ? 4 : 6;
                                let res = '';
                                for (let i = 0; i < name.length; i += charsPerRow) {
                                    res += name.substring(i, i + charsPerRow) + '\n';
                                }
                                return res.trim();
                            },
                            color: '#fff', 
                            // å¢å¤§å­—ä½“
                            fontSize: isMobile ? 12 : 14,
                            fontWeight: 'bold',
                            textShadowColor: 'rgba(0,0,0,0.3)', 
                            textShadowBlur: 2,
                            width: nodeWidth - 6,
                            overflow: 'break', // å…è®¸æ¢è¡Œ
                            lineHeight: isMobile ? 14 : 18, // å¢åŠ è¡Œé«˜
                            align: 'center',
                            verticalAlign: 'middle'
                        }
                    }));
                    
                    // è½¬æ¢é“¾æ¥æ•°æ®
                    const links = sankeyData.links
                        .filter(link => {
                            const sourceNode = sankeyData.nodes.find(n => n.id === link.source);
                            const targetNode = sankeyData.nodes.find(n => n.id === link.target);
                            return sourceNode && targetNode;
                        })
                        .map(link => {
                            const sourceNode = sankeyData.nodes.find(n => n.id === link.source);
                            return {
                                source: sourceNode.name,
                                target: sankeyData.nodes.find(n => n.id === link.target).name,
                                value: link.value || 0.5,
                                lineStyle: {
                                    color: 'source', 
                                    opacity: 0.3, // ç¨å¾®å¢åŠ ä¸é€æ˜åº¦
                                    curveness: 0.5
                                }
                            };
                        });
                    
                    if (links.length === 0) return;
                    
                    const option = {
                        title: {
                            text: 'ä¸»è¯‰ç—‡çŠ¶ â†’ åˆ†ææç‚¼ â†’ ç–‘ä¼¼æ‚£ç—…',
                            left: 'center',
                            top: 10,
                            textStyle: {
                                fontSize: isMobile ? 16 : 18,
                                color: '#111827',
                                fontWeight: '600'
                            }
                        },
                        tooltip: {
                            trigger: 'item',
                            triggerOn: 'mousemove',
                            backgroundColor: 'rgba(255, 255, 255, 0.95)',
                            borderColor: '#e5e7eb',
                            textStyle: { color: '#374151' },
                            extraCssText: 'box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); border-radius: 8px; z-index: 100;',
                            formatter: function(params) {
                                if (params.dataType === 'node') {
                                    const node = sankeyData.nodes.find(n => n.name === params.name);
                                    const category = node ? node.category : 'æœªçŸ¥';
                                    const color = node ? (node.color || getNodeColor(category)) : '#999';
                                    return `<div class="flex items-center space-x-2">
                                                <div class="w-3 h-3 rounded-full" style="background-color: ${color}"></div>
                                                <span class="font-bold">${params.name}</span>
                                            </div>
                                            <div class="mt-1 text-xs text-gray-500">
                                                åˆ†ç±»: <span class="px-1.5 py-0.5 rounded text-white" style="background-color: ${color}">${category}</span>
                                            </div>`;
                                } else {
                                    return `${params.data.source} <span class="text-gray-400">â†’</span> ${params.data.target}<br/>
                                            <span class="text-xs text-gray-500">å…³è”å¼ºåº¦: ${(params.data.value * 100).toFixed(0)}%</span>`;
                                }
                            }
                        },
                        series: [
                            {
                                type: 'sankey',
                                layout: 'none',
                                top: 60,
                                bottom: 20,
                                left: isMobile ? 0 : 20, 
                                right: isMobile ? 0 : 20,
                                nodeWidth: nodeWidth, 
                                nodeGap: 16,
                                layoutIterations: 32,
                                data: nodes,
                                links: links,
                                draggable: false,
                                focusNodeAdjacency: 'allEdges',
                                itemStyle: {
                                    borderWidth: 0
                                },
                                lineStyle: {
                                    curveness: 0.5
                                },
                                levels: [
                                    {
                                        depth: 0,
                                        itemStyle: { color: '#ec4899' },
                                        lineStyle: { color: 'source', opacity: 0.25 }
                                    },
                                    {
                                        depth: 1,
                                        itemStyle: { color: '#8b5cf6' },
                                        lineStyle: { color: 'source', opacity: 0.25 }
                                    },
                                    {
                                        depth: 2,
                                        itemStyle: { color: '#10b981' },
                                        lineStyle: { color: 'source', opacity: 0.25 }
                                    }
                                ],
                                label: {
                                    show: true
                                }
                            }
                        ]
                    };
                    
                    myChart.setOption(option);
                    window.addEventListener('resize', () => {
                        myChart.resize();
                        // é‡æ–°æ¸²æŸ“ä»¥é€‚é…å®½åº¦å˜åŒ–
                        renderSankeyChart(); 
                    });
                };

                const getNodeColor = (category) => {
                    const colors = {
                        'ç—‡çŠ¶': '#ec4899',     // ç²‰è‰²
                        'å‘ç—…æ—¶é—´': '#3b82f6', // è“è‰²
                        'éƒ¨ä½': '#f59e0b',     // æ©™è‰²
                        'åˆ†æ': '#8b5cf6',     // ç´«è‰²
                        'æ—¶é—´åˆ†æ': '#6366f1', // é›è“
                        'éƒ¨ä½åˆ†æ': '#d97706', // æ·±æ©™
                        'ç–‘ä¼¼æ‚£ç—…': '#10b981', // ç»¿è‰²
                        'å…¶ä»–': '#9ca3af'      // ç°è‰²
                    };
                    return colors[category] || colors['å…¶ä»–'];
                };

                // ç›‘å¬è¯Šæ–­ç»“æœå˜åŒ–ï¼Œæ¸²æŸ“æ¡‘åŸºå›¾
                const watchDiagnosis = () => {
                    if (diagnosis.value) {
                        nextTick(() => {
                            renderSankeyChart();
                        });
                    }
                };

                // æ·»åŠ Vueç›‘å¬å™¨
                watch(diagnosis, watchDiagnosis, { deep: true });

                return {
                    inputMessage,
                    isLoading,
                    history,
                    displayMessages,
                    sendMessage,
                    chatContainer,
                    diagnosis,
                    selectedModel,
                    isModelDropdownOpen,
                    modelDropdown,
                    availableModels,
                    getModelDisplayName,
                    toggleModelDropdown,
                    selectModel,
                    getUrgencyColor,
                    resetChat,
                    toggleOption,
                    submitCurrentOptions,
                    hasCurrentOptions,
                    getCurrentSelectedCount,
                    formatMessage,
                    getMessageEmoji,
                    getUserEmoji,
                    getOptionEmoji,
                    getStepTypeColor,
                    getStepBorderColor,
                    handleCamera,
                    handleAdd,
                    isVoiceMode,
                    isRecording,
                    toggleVoiceMode,
                    startRecording,
                    stopRecording,
                    mediaRecorder,
                    audioChunks,
                    isTTSEnabled,
                    isTTSPlaying,
                    displayAIMessageWithTTS,
                    previewImageUrl,
                    pendingImages,
                    previewImage,
                    closeImagePreview,
                    removeImage
                };
            }
        }).mount('#app');
    </script>
    
    <script>
        // ç¦ç”¨å³é”®èœå•
        document.addEventListener('contextmenu', function(e) {
            e.preventDefault();
        });
        
        // ç¦ç”¨é•¿æŒ‰å¼¹å‡ºèœå•ï¼ˆç§»åŠ¨ç«¯ï¼‰
        let longPressTimer = null;
        document.addEventListener('touchstart', function(e) {
            // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
            if (longPressTimer) {
                clearTimeout(longPressTimer);
            }
            // è®¾ç½®é•¿æŒ‰æ£€æµ‹
            longPressTimer = setTimeout(function() {
                e.preventDefault();
            }, 500);
        }, { passive: false });
        
        document.addEventListener('touchend', function() {
            // æ¸…é™¤é•¿æŒ‰å®šæ—¶å™¨
            if (longPressTimer) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
            }
        });
        
        document.addEventListener('touchmove', function() {
            // ç§»åŠ¨æ—¶å–æ¶ˆé•¿æŒ‰
            if (longPressTimer) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
            }
        });
        
        // ç¦ç”¨é€‰æ‹©æ–‡æœ¬ï¼ˆé˜²æ­¢é•¿æŒ‰é€‰æ‹©ï¼‰
        document.addEventListener('selectstart', function(e) {
            // å…è®¸åœ¨è¾“å…¥æ¡†ä¸­é€‰æ‹©æ–‡æœ¬
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }
            e.preventDefault();
        });
    </script>
</body>
</html>

